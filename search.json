[{"title":"第十二届蓝桥杯省赛第一场 C/C++ 组题解","url":"/2022/04/12/LQ12province1-C/","content":" embedpdf(\"题面\", [\"LQ12province1_CA\", \"LQ12province1_CB\"]) \n\n空间常识题，1MB&#x3D;1024KB, 1KB&#x3D;1024Bytes, 1Byte&#x3D;8bits\n故 256MB 可以存储 $256 \\times 1024 \\times 1024 \\times 8 \\div 32&#x3D;67108864$ 个 32 位二进制整数。\n答案：$67108864$\n卡片模拟即可，首先开一个数组 $a$，记录 $0 \\sim 9$ 的卡片各有 $2021$ 张\n$i$ 从 $1$ 开始递增，对于每个 $i$，遍历其所有数位的数字，于数组 $a$ 中使卡片数量减 $1$，若发现无法减了（值为 $0$），则说明 $i$ 拼不出来，那么答案就是 $i-1$。\n答案：$3181$\n\nCode\n\n\n\n直线我们只需要遍历所有点对，对于每对点对求出其所成直线的一般式（为什么是一般式？因为斜截式这种涉及到浮点数的方式，会因精度问题导致答案错误），然后装进 std::set 去重（$Ax+By+C&#x3D;0$ 只需要装 $(A,B,C)$ 即可），最后输出 std::set 的大小即可\n当然，因为一条直线有无限个一般式，所以不要忘记约分\n答案：$40257$\n\nCode\n\n\n\n货物摆放枚举直接暴力遍历 $L$ 和 $W$，$H$ 随之确定即可\n注意不是直接 $O(n^2)$ 暴力，$n&#x3D;2021041820210418$，这属于作死\n容易发现，其实 $L$、$W$、$H$ 的组合只需要得出一次即可，因为三个数的其他组合可以靠组合数学解决：\n\n若三个数互相不同，共有 $6$ 种排列方式\n若只有两个数相同，共有 $3$ 种排列方式\n若三个数相等，共有 $1$ 种排列方式\n\n所以说 $L$ 只需要遍历到 $\\sqrt[3]{n}$，$W$ 只需要遍历到 $\\sqrt{\\frac{n}{L}}$ 即可\n质因数分解首先找出 $2021041820210418$ 的质因子：\n$$2,3,3,3,17,131,2857,5882353$$\n然后问题就变成了把这 $8$ 个数分到三个集合（乘积分别作为 $L,W,H$）内且允许出现空集（视为 $1$）有几种方法。\n于是 $3^5 \\times (1+3+6) &#x3D; 2430$\n答案：$2430$\n路径最短路裸题，因为没有负权边所以 Bellman-Ford，Dijkstra，甚至 Floyd 都行（反正是提答题）。\n答案：$10266837$\n\nCode\n\n\n\n回路计数dfs 爆搜时间复杂度过于巨大，显然不行。需要用状压 dp 来优化\n\n状态设计：$dp[set][u]$ 代表当前到达点 $u$ 处且已经到达了 $set$ 中所有点的方案数（$u \\in set$）\n初始状态：$dp[{1}][1]&#x3D;1$\n转移方程：$$dp[set][u]&#x3D;\\sum_{v \\in set,(u,v) \\in E}dp[set-u][v]$$\n所求答案：$$\\sum_{u \\in V,(1,u) \\in E}dp[V][u]$$\n\n$set$ 为可用一二进制数 $s$ 表示（状态压缩），$s$ 的第 $i$ 位为 $1$ 代表 $i$ 结点已到达过\n答案：$881012367360$\n\nCode\n\n\n\n时间显示题目给的输入即为毫秒级的 UNIX 时间戳，直接调库即可，注意需要输出 GMT 时间而不是 UTC 时间。\n\nC/C++：先把毫秒转化为秒，然后用 gmtime 转 tm 后再用 strftime 格式化输出。\nJava：Date 可以直接用毫秒时间戳构造，用 SimpleDateFormat 设置 GMT 时区后格式化输出。\nPython：先把毫秒转化为秒，time.gmtime 后 time.strftime 格式化输出。\n\n当然不会调库的话也可以不调，因为只需要输出时分秒，所以把毫秒转换为秒后再对 $60 \\times 60 \\times 24&#x3D;86400$ 取模，然后再转换出时分秒即可。\n\nCode\n\n\n\n砝码称重天平问题是经典的背包问题\n\n状态设计：$dp[i][j]$ 表示选到第 $i$ 个砝码时重量 $j$ 能否称出来\n初始状态：$dp[i][w_i]&#x3D;true$\n状态转移方程：$$dp[i][j]&#x3D;dp[i-1][j] \\lor dp[i-1][|j-w_i|] \\lor dp[i-1][j+w[i]]$$\n所求答案：$$\\sum_{j&#x3D;1}^{\\sum w_i}[dp[n][j]&#x3D;true]$$\n\n第一维的转移只跟上一维有关，可以把式子拆开后使用滚动数组优化，不过在实现时要注意 $j$ 遍历的顺序\n$$dp[j]&#x3D;dp[j] \\lor dp[j-w_i],~dp[j]&#x3D;dp[j] \\lor dp[j+w_i]$$\n\nCode\n\n\n\n杨辉三角形首先，本题一定有解，因为 $\\dbinom{n}{1}&#x3D;n$\n直接递推杨辉三角只能拿20分，空间及时间复杂度都太大了——都是 $O(n^2)$，我们需要分析一下\n显然杨辉三角形的右半部分是没用的，直接去掉即可\n对于杨辉三角中的任意一个数字，可以发现其必定大于其左上方的所有数字，也就是说我们可以把杨辉三角分成若干从右上到左下的斜列\n我们简单一些考虑，能递推出来的就暴力递推，不能递推出来的找规律算出来就是了：\n\n假设 $N$ 在第二斜列，那么显然最坏需要推 $N$ 层，不能承受，但显然第二斜列上数字对应行数，$N$ 即为数列的第 $\\frac{N(N+1)}{2}+2$ 项\n假设 $N$ 在第三斜列，那么最坏需要推 $\\dbinom{r}{3} \\leq {10}^9$ 解得 $r&lt;&#x3D;44722$ 层，还是不能承受。但我们发现第三斜列上的数字是逐行 $+4,+5,\\cdots$ 的，所以一个循环遍历一下就好了\n假设 $N$ 在第四斜列，那么最坏需要推 $\\dbinom{r}{4} \\leq {10}^9$ 解得 $r&lt;&#x3D;1819$ 层，这个是可以承受的，可以直接递推。另外显然第四斜列之后的斜列需要推的层数更少\n\n所以我们的解题步骤即：首先递推出前 $1819$ 层，若发现 $N$ 则直接输出其位置。若没发现则遍历第三斜列。若还是没发现则答案为 $\\frac{N(N+1)}{2}+2$。\n\nCode\n\n\n\n双向排序直接暴力排序的时间复杂度为 $O(mn\\log{n})$ 的，只能得到 $60$ 分。\n栈我们可以发现，对于连续的几条同一种操作，显然覆盖范围最广的会覆盖掉其它操作，所以首先我们使用一个栈来维护操作，使得两种操作在栈内交替出现\n然后，对于每个操作：\n\n若该操作与上一条操作的覆盖范围不相交，则该操作无效\n若该操作与上一条操作的覆盖范围相交，那么：\n若相交的范围在上一对操作的相交范围之内，则对相交部分进行翻转即可\n若相交的范围不在上一对操作的相交范围之内，则上一对操作无效\n\n\n\n可以发现我们需要做的事情只有不停的翻转某区间，而且需要翻转的区间是在不停变小的，所以说范围外的值一旦确定就不会更改，直接填数就好了\n时间复杂度 $O(n+m)$\n线段树分裂合并本题为 [HEOI2016&#x2F;TJOI2016]排序 的弱化版，故解决方法相同：线段树分裂合并。\n因为值域线段树上的数是有序的，故对于排序操作即通过线段树的分裂合并操作使用一个值域线段树维护操作区间即可。\n时间复杂度 $O(m\\log{n})$\n\nCode\n\n\n\n异或数列因为是最后剩下的数字比较大的一方获胜，所以我们只需要从高到低考虑每个二进制位即可：如果某个二进制位上已经可以决出胜负，则结束；如果每一位都是平局则平局\n对于所有数字的某位：\n\n若 $1$ 的数量为偶数（包括 $0$ 个），因为所有的 $1$ 都要用上，所以必定平局；\n若 $1$ 的数量为奇数且没有 $0$，因为当 $1$ 的数量为偶数时必定平局，所以当 $1$ 的数量为奇数时因为该先手方进行操作故先手方只需要给自己异或 $1$ 即可必胜。\n若有 $0$ 的存在，因为 $0$ 异或一个数结果还是这个数所以选择用 $0$ 异或相当于换手\n若 $0$ 的数量为偶数，因为所有 $0$ 都要用上，所以相当于没有 $0$（换手再换手等于没换）\n若 $0$ 的数量为奇数，相当于只有 $1$ 个 $0$\n若 $1$ 的数量为 $1$，先手方只需要给自己异或上 $1$ 即可胜出\n若 $1$ 的数量为 $3,5,7,\\cdots$，因为 $0$ 的存在导致后手方可以变为先手，所以本来的先手必胜变成了后手必胜\n\n\n\n\n\n为什么当 $0$ 的数量为奇数 $1$ 的数量为 $1$ 时同样是奇数却是先手必胜呢？因为后手方利用换手获胜的必要条件是换手后还有 $1$ 进行操作，而 $1$ 的数量为 $1$ 时先手方给自己异或上 $1$ 后导致没有剩余的 $1$ 进行操作了，后手方的换手就变成了无用之举\n\nCode\n\n\n\n左孩子右兄弟显然对于一个结点我们只需要贪心地把其高度最高的子树尽量往下挂即可，极为简单的一道树上 DP\n\n状态设计：$dp[u]$ 代表 $u$ 结点对高度的最大贡献\n初始状态：$dp[leaf]&#x3D;0$\n状态转移：$$dp[u]&#x3D;son[u].length + \\max_{v \\in son[u]}dp[v]$$\n所求答案：$dp[rt]$\n\n\nCode\n\n\n\n括号序列因为尽可能添加少的括号，所以添加的左、右括号不会出现如同 () 的形式，所以左括号与右括号添加的位置方案是相互独立的，不会相互影响。故总的方案数等于左括号的方案数 $\\times$ 右括号的方案数。继续转换成只需要添加左括号：当需要添加右括号时将整个括号序列对称翻转，就转化为只需要添加左括号了\n若以右括号为分割点将整个序列进行分割，因为分割后的子串中均为左括号，添加任意数目的左括号方案数均为一种，那么此时我们仅需考虑添加不同数量的左括号的方案数即可。采用 DP：\n设 $n$ 为右括号数，$x$ 为共需添加多少个左括号，$b$ 代表当前至少需添加多少个左括号\n\n状态设计：$dp[i][j]$ 代表只考虑前 $i$ 个右括号，需要添加 $j$ 个左括号的方案数\n初始状态：$dp[1][~]&#x3D;1$\n状态转移：$$dp[i][j]&#x3D;\\sum_{k&#x3D;b}^{x}dp[i-1][k]$$\n所求结果：$dp[n][x]$\n\n\nCode\n\n\n\n分果果待填坑……\n","categories":["题解"],"tags":["蓝桥杯"]},{"title":"第十二届蓝桥杯省赛第二场 C/C++ 组题解","url":"/2022/04/11/LQ12province2-C/","content":" embedpdf(\"题面\", [\"LQ12province2_CA\", \"LQ12province2_CB\"]) \n\n求余送分题\n答案：$1$\n\nCode\n\n\n\n双阶乘只需要维护最后 $5$ 位即可，于是一个 for 搞定，边乘边对 ${10}^5$ 取模\n答案：$59375$\n\nCode\n\n\n\n格点两重 for 遍历 $x,y$ 值然后加一个判断计数即可\n答案：$15698$\n\nCode\n\n\n\n整数分解注意到所求为方案数，求方案数常见两种方法：组合数学或动态规划\n本题两种方法均可\n组合数学显然题目即为在 $2021$ 个 $1$ 的 $2020$ 个空隙中插入 $4$ 个隔板的方案数\n故答案为：$\\binom{2020}{4}&#x3D;691677274345$\n动态规划\n状态设计：$dp[i][j]$ 表示 $i$ 分成 $j$ 个正整数之和的方案数\n初始状态：$dp[i][1] &#x3D; 1$\n转移方程：$$dp[i][j] &#x3D; \\sum_{k&#x3D;1}^{i-1} dp[k][j-1]$$\n所求结果：$dp[2021][5] &#x3D; 691677274345$\n\n答案：$691677274345$\n\nCode\n\n\n\n城邦显然最小生成树裸题，下一道\n答案：$4046$\n\nCode\n\n\n\n游戏又是求方案数，发现这回不能用组合数学了，于是思路转向 DP\n\n状态设计：$dp[i]$ 表示从 $i$ 开始写的方案数\n初始状态：$dp[1] &#x3D; 1$\n转移方程：$$dp[i] &#x3D; \\sum_{d|i} dp[d]$$\n所求结果：$$\\sum_{i&#x3D;1}^{n} dp[i]$$\n\n发现直接递推的话，对于每个数都需要 $O(\\sqrt n)$ 找约数，时间复杂度是 $O(n \\sqrt n)$ 的，有些慢。于是我们采用刷表法优化，用前向状态去更新后继状态，即用每个数的 DP 值去更新其倍数的 DP 值。时间复杂度 $O(n \\log n)$\n答案：$1352184317599$\n\nCode\n\n\n\n特殊年份模拟即可\n使用 std::string 可以非常简单地写出程序\n\nCode\n\n\n\n小平方模拟……开个 for 循环即可\n\nCode\n\n\n\n完全平方数设 $A$ 为完全平方数，有：$A&#x3D;x \\times x$\n设 $x$ 的标准质因数分解式为：\n$$x&#x3D;{p_1}^{\\alpha_1}{p_2}^{\\alpha_2} \\cdots {p_s}^{\\alpha_s}$$\n则 $A$ 的标准质因数分解式为：\n$$A&#x3D;{p_1}^{2\\alpha_1}{p_2}^{2\\alpha_2} \\cdots {p_s}^{2\\alpha_s}$$\n即 $A$ 的所有质因数都一定出现偶数次，故我们只需要对 $n$ 进行质因数分解，然后将所有出现了奇数次方的质因数乘在一起即为答案（将奇数补成偶数）。时间复杂度：$O(\\sqrt n)$\n\nCode\n\n\n\n负载均衡可以把分配任务想象成向计算机借了一些算力，时间到了后再还回去\n于是我们开一个堆来维护要还回去的算力，对于每次操作先把时间到了的需要还回去的算力还回去，再判断此次能否借来算力，若能借来算力，把计算机的算力扣除了借走的算力后，在堆中打一个欠条。重复此流程即可，时间复杂度：$O(n \\log n)$\n\nCode\n\n\n\n国际象棋发现此题即 [SCOI2005] 互不侵犯 的加强版。把王换成马，即会跟上两行有关系罢了\n状压 DP，把每行棋子放法用 01 串来表示，放了马为 1，没放为 0：\n\n状态设计：$dp[i][p][q][j]$ 代表当前放到第 $i$ 行，放法为 $p$，上一行放法为 $q$，已经放了 $j$ 个马的方案数\n初始状态：$dp[1][p][0][popcount(p)] &#x3D; 1,p \\in [0, 2^n-1]$ （同一行的马不会互相攻击所以可以随便放）\n转移方程：$$dp[i][p][q][j] &#x3D; \\sum_{a} dp[i-1][q][a][j-popcount(p)],j \\in [popcount(p),k],(q,p) \\And (a,p) \\text{不冲突}$$\n所求结果：$$\\sum_{p&#x3D;0}^{2^n-1} \\sum_{q&#x3D;0}^{2^n-1} dp[m][p][q][k]$$\n\n注意数据范围 $n&lt;&#x3D;6,~m&lt;&#x3D;100$，即 $2^m &gt;&gt; 2^n$，故我们把 $m$ 当做行来处理可以极大地缩小空间时间复杂度，最终时间复杂度：$O(m \\times 2^n \\times 2^n \\times 2^n \\times k) &#x3D; O(8^nmk)$\n\nCode\n\n\n\n完美序列鸣谢：感谢 @Tifa 大佬提供的主要思路\n读完题目，我们可以轻松获取如下三个结论（以下简称“$1$ 至 $n$ 的所有排列中长度正好为 $n$ 阶最大完美长度的最长完美子序列”为“最长完美子序列”：\n\n$n$ 阶最大完美长度为 $\\lfloor \\log_2 n \\rfloor + 1$\n每个“最长完美子序列”一定以 $1$ 为结尾\n每个“最长完美子序列”中一定只存在前一个数是后一个数的 $2$ 倍或 $3$ 倍，且 $3$ 倍只出现一次\n\n第一个结论是显然的，因为下降最慢的完美序列为等比数列 $2^k,2^{k-1},\\cdots,1$，故一个最大值为 $n$ 的完美序列的最大长度为 $\\lfloor \\log_2 n \\rfloor + 1$\n第二个结论采取反证法：若存在一个“最长完美子序列” $P$ 不以 $1$ 为结尾，那么一定存在一个完美子序列 $Q&#x3D;(P,1)$ 比 $P$ 长，那么 $P$ 必然不是最长的，矛盾\n第三个结论采取反证法：首先，若出现了 $3$ 倍以上，即以长度 $2$ 出现了 $3$ 倍以上（例：$5,1$），但我们至少可以用长度 $3$ 来出现 $4$ 倍（$4,2,1$），也就说说若出现了 $3$ 倍以上，那么此“最长完美子序列”必然不是最长的，矛盾；其次，若出现了两个 $3$ 倍，即以长度 $3$ 出现了 $9$ 倍（例：$9,3,1$），但我们可以用长度 $4$ 来出现 $8$ 倍（$8,4,2,1$），也就是说若出现了 $9$ 倍，那么此“最长完美子序列”必然不是最长的，矛盾\n有了如上三个结论，我们就可以开始考虑如何解决这个问题了。设 $n$ 阶最大完美长度为 $len&#x3D;\\lfloor \\log_2 n \\rfloor + 1$，我们分情况讨论：\n“最长完美子序列”中不存在 $3$ 倍，即“最长完美子序列”为：$2^{len-1} \\rightarrow 1$此时“最长完美子序列”为等比数列 $2^{len-1},2^{len-2},\\cdots,1$，由等比数列求和公式 $S_n&#x3D;\\cfrac{a_1-a_{n}q}{1-q}$，此情况下“最长完美子序列”的和为：\n$$\\cfrac{2^{len-1}-1 \\times \\frac{1}{2}}{1-\\frac{1}{2}}&#x3D;2^{len}-1$$\n“最长完美子序列”中存在 $3$ 倍，即“最长完美子序列”为：$3 \\cdot 2^{len-2} \\rightarrow 1$注意：只有当 $n \\geq 3 \\cdot 2^{len-2}$ 时才会出现此情况\n设 $S_{len}$ 为存在 $3$ 倍情况下所有长度为 $len$ 的“最长完美子序列”的和，则有：\n\n递推预处理即可。以 $len&#x3D;5$ 为例，上式的各部分如下：\n\n当然，也可以使用此递推式的通项公式 $S_{len}&#x3D;2^{len-1}(3len-4) - len + 2$ 直接算出结果\n于是对于一个给定的 $n$，我们只需要判断一下是否可能出现第二种情况，根据上文所述即可获取所有“最长完美子序列”的和\n注意“最长完美子序列”是 $1$ 至 $n$ 的所有排列的子序列，也就是说每个“最长完美子序列”会出现多次，其出现次数为 $\\cfrac{A_n^n}{A_{len}^{len}}&#x3D;\\cfrac{n!}{len!}$，在计算答案时需要乘进去\n为什么是 $\\cfrac{A_n^n}{A_{len}^{len}}$ 呢？$1$ 至 $n$ 的所有排列共有 $A_n^n$ 个，而其中“最长完美子序列”的相对位置是不变的，所以除掉“最长完美子序列”的排列数 $A_{len}^{len}$\n注意到出现了有理数取余，需要预处理阶乘及其逆元 $\\left[ \\cfrac{n!}{len!} \\equiv n! \\times (len!)^{-1} \\pmod p \\right]$。数据规模 $n \\leq {10}^6$ 不是很大，采用 $O(n + \\log p)$ 或者 $O(n \\log n)$ 求逆元都可以。\n若采用 $O(n \\log n)$ 求逆元则总时间复杂度为 $O(n \\log n + T)$；若采用 $O(n + \\log p)$ 求逆元则总时间复杂度为 $O(n + \\log p + T)$\n\nCode\n\n\n","categories":["题解"],"tags":["蓝桥杯"]}]