[{"title":"第十二届蓝桥杯省赛第一场 C/C++ 组题解","url":"/2022/04/12/LQ12province1-C/","content":" embedpdf(\"题面\", [\"LQ12province1_CA\", \"LQ12province1_CB\"]) \n空间\n常识题，1MB=1024KB, 1KB=1024Bytes, 1Byte=8bits\n故 256MB 可以存储 \\(256 \\times 1024 \\times 1024 \\times 8 \\div 32=67108864\\) 个 32 位二进制整数。\n答案：\\(67108864\\)\n卡片\n模拟即可，首先开一个数组 \\(a\\)，记录 \\(0 \\sim 9\\) 的卡片各有 \\(2021\\) 张\n\\(i\\) 从 \\(1\\) 开始递增，对于每个 \\(i\\)，遍历其所有数位的数字，于数组 \\(a\\) 中使卡片数量减 \\(1\\)，若发现无法减了（值为 \\(0\\)），则说明 \\(i\\) 拼不出来，那么答案就是 \\(i-1\\)。\n答案：\\(3181\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/2.cpp\") \n直线\n我们只需要遍历所有点对，对于每对点对求出其所成直线的一般式（为什么是一般式？因为斜截式这种涉及到浮点数的方式，会因精度问题导致答案错误），然后装进 std::set 去重（\\(Ax+By+C=0\\) 只需要装 \\((A,B,C)\\) 即可），最后输出 std::set 的大小即可\n当然，因为一条直线有无限个一般式，所以不要忘记约分\n答案：\\(40257\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/3.cpp\") \n货物摆放\n枚举\n直接暴力遍历 \\(L\\) 和 \\(W\\)，\\(H\\) 随之确定即可\n注意不是直接 \\(O(n^3)\\) 暴力，\\(n=2021041820210418\\)，这属于作死\n容易发现，其实 \\(L\\)、\\(W\\)、\\(H\\) 的组合只需要得出一次即可，因为三个数的其他组合可以靠组合数学解决：\n\n若三个数互相不同，共有 \\(6\\) 种排列方式\n若只有两个数相同，共有 \\(3\\) 种排列方式\n若三个数相等，共有 \\(1\\) 种排列方式\n\n所以说 \\(L\\) 只需要遍历到 \\(\\sqrt[3]{n}\\)，\\(W\\) 只需要遍历到 \\(\\sqrt{\\frac{n}{L}}\\) 即可\n质因数分解\n首先找出 \\(2021041820210418\\) 的质因子：\n\\[2,3,3,3,17,131,2857,5882353\\]\n然后问题就变成了把这 \\(8\\) 个数分到三个集合（乘积分别作为 \\(L,W,H\\)）内且允许出现空集（视为 \\(1\\)）有几种方法。\n于是 \\(3^5 \\times (1+3+6) = 2430\\)\n答案：\\(2430\\)\n路径\n最短路裸题，因为没有负权边所以 Bellman-Ford，Dijkstra，甚至 Floyd 都行（反正是提答题）。\n答案：\\(10266837\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/5.cpp\") \n回路计数\ndfs 爆搜时间复杂度过于巨大，显然不行。需要用状压 dp 来优化\n\n状态设计：\\(dp[set][u]\\) 代表当前到达点 \\(u\\) 处且已经到达了 \\(set\\) 中所有点的方案数（\\(u \\in set\\)）\n初始状态：\\(dp[\\{1\\}][1]=1\\)\n转移方程：\\[dp[set][u]=\\sum_{v \\in set,(u,v) \\in E}dp[set-u][v]\\]\n所求答案：\\[\\sum_{u \\in V,(1,u) \\in E}dp[V][u]\\]\n\n\\(set\\) 为可用一二进制数 \\(s\\) 表示（状态压缩），\\(s\\) 的第 \\(i\\) 位为 \\(1\\) 代表 \\(i\\) 结点已到达过\n答案：\\(881012367360\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/6.cpp\") \n时间显示\n题目给的输入即为毫秒级的 UNIX 时间戳，直接调库即可，注意需要输出 GMT 时间而不是 UTC 时间。\n\nC/C++：先把毫秒转化为秒，然后用 gmtime 转 tm 后再用 strftime 格式化输出。\nJava：Date 可以直接用毫秒时间戳构造，用 SimpleDateFormat 设置 GMT 时区后格式化输出。\nPython：先把毫秒转化为秒，time.gmtime 后 time.strftime 格式化输出。\n\n当然不会调库的话也可以不调，因为只需要输出时分秒，所以把毫秒转换为秒后再对 \\(60 \\times 60 \\times 24=86400\\) 取模，然后再转换出时分秒即可。\n embedcode(\"C++\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/7.cpp\") \n embedcode(\"Java\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/7.java\") \n embedcode(\"Python\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/7.py\") \n砝码称重\n天平问题是经典的背包问题\n\n状态设计：\\(dp[i][j]\\) 表示选到第 \\(i\\) 个砝码时重量 \\(j\\) 能否称出来\n初始状态：\\(dp[i][w_i]=true\\)\n状态转移方程：\\[dp[i][j]=dp[i-1][j] \\lor dp[i-1][|j-w_i|] \\lor dp[i-1][j+w[i]]\\]\n所求答案：\\[\\sum_{j=1}^{\\sum w_i}[dp[n][j]=true]\\]\n\n第一维的转移只跟上一维有关，可以把式子拆开后使用滚动数组优化，不过在实现时要注意 \\(j\\) 遍历的顺序\n\\[dp[j]=dp[j] \\lor dp[j-w_i],~dp[j]=dp[j] \\lor dp[j+w_i]\\]\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/8.cpp\") \n杨辉三角形\n首先，本题一定有解，因为 \\(\\dbinom{n}{1}=n\\)\n直接递推杨辉三角只能拿 20 分，空间及时间复杂度都太大了——都是 \\(O(n^2)\\)，我们需要分析一下\n显然杨辉三角形的右半部分是没用的，直接去掉即可\n对于杨辉三角中的任意一个数字，可以发现其必定大于其左上方的所有数字，也就是说我们可以把杨辉三角分成若干从右上到左下的斜列\n我们简单一些考虑，能递推出来的就暴力递推，不能递推出来的找规律算出来就是了：\n\n假设 \\(N\\) 在第二斜列，那么显然最坏需要推 \\(N\\) 层，不能承受，但显然第二斜列上数字对应行数，\\(N\\) 即为数列的第 \\(\\frac{N(N+1)}{2}+2\\) 项\n假设 \\(N\\) 在第三斜列，那么最坏需要推 \\(\\dbinom{r}{3} \\leq {10}^9\\) 解得 \\(r&lt;=44722\\) 层，还是不能承受。但我们发现第三斜列上的数字是逐行 \\(+4,+5,\\cdots\\) 的，所以一个循环遍历一下就好了\n假设 \\(N\\) 在第四斜列，那么最坏需要推 \\(\\dbinom{r}{4} \\leq {10}^9\\) 解得 \\(r&lt;=1819\\) 层，这个是可以承受的，可以直接递推。另外显然第四斜列之后的斜列需要推的层数更少\n\n所以我们的解题步骤即：首先递推出前 \\(1819\\) 层，若发现 \\(N\\) 则直接输出其位置。若没发现则遍历第三斜列。若还是没发现则答案为 \\(\\frac{N(N+1)}{2}+2\\)。\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/9.cpp\") \n双向排序\n直接暴力排序的时间复杂度为 \\(O(mn\\log{n})\\) 的，只能得到 \\(60\\) 分。\n栈\n我们可以发现，对于连续的几条同一种操作，显然覆盖范围最广的会覆盖掉其它操作，所以首先我们使用一个栈来维护操作，使得两种操作在栈内交替出现\n然后，对于每个操作：\n\n若该操作与上一条操作的覆盖范围不相交，则该操作无效\n若该操作与上一条操作的覆盖范围相交，那么：\n\n若相交的范围在上一对操作的相交范围之内，则对相交部分进行翻转即可\n若相交的范围不在上一对操作的相交范围之内，则上一对操作无效\n\n\n可以发现我们需要做的事情只有不停的翻转某区间，而且需要翻转的区间是在不停变小的，所以说范围外的值一旦确定就不会更改，直接填数就好了\n时间复杂度 \\(O(n+m)\\)\n线段树分裂合并\n本题为 [HEOI2016/TJOI2016]排序 的弱化版，故解决方法相同：线段树分裂合并。\n因为值域线段树上的数是有序的，故对于排序操作即通过线段树的分裂合并操作使用一个值域线段树维护操作区间即可。\n时间复杂度 \\(O(m\\log{n})\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/10.cpp\") \n异或数列\n因为是最后剩下的数字比较大的一方获胜，所以我们只需要从高到低考虑每个二进制位即可：如果某个二进制位上已经可以决出胜负，则结束；如果每一位都是平局则平局\n对于所有数字的某位：\n\n若 \\(1\\) 的数量为偶数（包括 \\(0\\) 个），因为所有的 \\(1\\) 都要用上，所以必定平局；\n若 \\(1\\) 的数量为奇数且没有 \\(0\\)，因为当 \\(1\\) 的数量为偶数时必定平局，所以当 \\(1\\) 的数量为奇数时因为该先手方进行操作故先手方只需要给自己异或 \\(1\\) 即可必胜。\n若有 \\(0\\) 的存在，因为 \\(0\\) 异或一个数结果还是这个数所以选择用 \\(0\\) 异或相当于换手\n\n若 \\(0\\) 的数量为偶数，因为所有 \\(0\\) 都要用上，所以相当于没有 \\(0\\)（换手再换手等于没换）\n若 \\(0\\) 的数量为奇数，相当于只有 \\(1\\) 个 \\(0\\)\n\n若 \\(1\\) 的数量为 \\(1\\)，先手方只需要给自己异或上 \\(1\\) 即可胜出\n若 \\(1\\) 的数量为 \\(3,5,7,\\cdots\\)，因为 \\(0\\) 的存在导致后手方可以变为先手，所以本来的先手必胜变成了后手必胜\n\n\n\n为什么当 \\(0\\) 的数量为奇数 \\(1\\) 的数量为 \\(1\\) 时同样是奇数却是先手必胜呢？因为后手方利用换手获胜的必要条件是换手后还有 \\(1\\) 进行操作，而 \\(1\\) 的数量为 \\(1\\) 时先手方给自己异或上 \\(1\\) 后导致没有剩余的 \\(1\\) 进行操作了，后手方的换手就变成了无用之举\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/11.cpp\") \n左孩子右兄弟\n显然对于一个结点我们只需要贪心地把其高度最高的子树尽量往下挂即可，极为简单的一道树上 DP\n\n状态设计：\\(dp[u]\\) 代表 \\(u\\) 结点对高度的最大贡献\n初始状态：\\(dp[leaf]=0\\)\n状态转移：\\[dp[u]=son[u].length + \\max_{v \\in son[u]}dp[v]\\]\n所求答案：\\(dp[rt]\\)\n\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/12.cpp\") \n括号序列\n因为尽可能添加少的括号，所以添加的左、右括号不会出现如同 () 的形式，所以左括号与右括号添加的位置方案是相互独立的，不会相互影响。故总的方案数等于左括号的方案数 \\(\\times\\) 右括号的方案数。继续转换成只需要添加左括号：当需要添加右括号时将整个括号序列对称翻转，就转化为只需要添加左括号了\n若以右括号为分割点将整个序列进行分割，因为分割后的子串中均为左括号，添加任意数目的左括号方案数均为一种，那么此时我们仅需考虑添加不同数量的左括号的方案数即可。采用 DP：\n设 \\(n\\) 为右括号数，\\(x\\) 为共需添加多少个左括号，\\(b\\) 代表当前至少需添加多少个左括号\n\n状态设计：\\(dp[i][j]\\) 代表只考虑前 \\(i\\) 个右括号，需要添加 \\(j\\) 个左括号的方案数\n初始状态：\\(dp[1][~]=1\\)\n状态转移：\\[dp[i][j]=\\sum_{k=b}^{x}dp[i-1][k]\\]\n所求结果：\\(dp[n][x]\\)\n\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province1/C/13.cpp\") \n分果果\n待填坑……\n","categories":["题解"],"tags":["蓝桥杯"]},{"title":"第十二届蓝桥杯省赛第二场 C/C++ 组题解","url":"/2022/04/11/LQ12province2-C/","content":" embedpdf(\"题面\", [\"LQ12province2_CA\", \"LQ12province2_CB\"]) \n求余\n送分题\n答案：\\(1\\)\n双阶乘\n只需要维护最后 \\(5\\) 位即可，于是一个 for 搞定，边乘边对 \\({10}^5\\) 取模\n答案：\\(59375\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/2.cpp\") \n格点\n两重 for 遍历 \\(x,y\\) 值然后加一个判断计数即可\n答案：\\(15698\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/3.cpp\") \n整数分解\n注意到所求为方案数，求方案数常见两种方法：组合数学或动态规划\n本题两种方法均可\n组合数学\n显然题目即为在 \\(2021\\) 个 \\(1\\) 的 \\(2020\\) 个空隙中插入 \\(4\\) 个隔板的方案数\n故答案为：\\(\\binom{2020}{4}=691677274345\\)\n动态规划\n\n状态设计：\\(dp[i][j]\\) 表示 \\(i\\) 分成 \\(j\\) 个正整数之和的方案数\n初始状态：\\(dp[i][1] = 1\\)\n转移方程：\\[dp[i][j] = \\sum_{k=1}^{i-1} dp[k][j-1]\\]\n所求结果：\\(dp[2021][5] = 691677274345\\)\n\n答案：\\(691677274345\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/4.cpp\") \n城邦\n显然最小生成树裸题，下一道\n答案：\\(4046\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/5.cpp\") \n游戏\n又是求方案数，发现这回不能用组合数学了，于是思路转向 DP\n\n状态设计：\\(dp[i]\\) 表示从 \\(i\\) 开始写的方案数\n初始状态：\\(dp[1] = 1\\)\n转移方程：\\[dp[i] = \\sum_{d|i} dp[d]\\]\n所求结果：\\[\\sum_{i=1}^{n} dp[i]\\]\n\n发现直接递推的话，对于每个数都需要 \\(O(\\sqrt n)\\) 找约数，时间复杂度是 \\(O(n \\sqrt n)\\) 的，有些慢。于是我们采用刷表法优化，用前向状态去更新后继状态，即用每个数的 DP 值去更新其倍数的 DP 值。时间复杂度 \\(O(n \\log n)\\)\n答案：\\(1352184317599\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/6.cpp\") \n特殊年份\n模拟即可\n使用 std::string 可以非常简单地写出程序\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/7.cpp\") \n小平方\n模拟……开个 for 循环即可\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/8.cpp\") \n完全平方数\n设 \\(A\\) 为完全平方数，有：\\(A=x \\times x\\)\n设 \\(x\\) 的标准质因数分解式为：\n\\[x={p_1}^{\\alpha_1}{p_2}^{\\alpha_2} \\cdots {p_s}^{\\alpha_s}\\]\n则 \\(A\\) 的标准质因数分解式为：\n\\[A={p_1}^{2\\alpha_1}{p_2}^{2\\alpha_2} \\cdots {p_s}^{2\\alpha_s}\\]\n即 \\(A\\) 的所有质因数都一定出现偶数次，故我们只需要对 \\(n\\) 进行质因数分解，然后将所有出现了奇数次方的质因数乘在一起即为答案（将奇数补成偶数）。时间复杂度：\\(O(\\sqrt n)\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/9.cpp\") \n负载均衡\n可以把分配任务想象成向计算机借了一些算力，时间到了后再还回去\n于是我们开一个堆来维护要还回去的算力，对于每次操作先把时间到了的需要还回去的算力还回去，再判断此次能否借来算力，若能借来算力，把计算机的算力扣除了借走的算力后，在堆中打一个欠条。重复此流程即可，时间复杂度：\\(O(n \\log n)\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/10.cpp\") \n国际象棋\n发现此题即 [SCOI2005] 互不侵犯 的加强版。把王换成马，即会跟上两行有关系罢了\n状压 DP，把每行棋子放法用 01 串来表示，放了马为 1，没放为 0：\n\n状态设计：\\(dp[i][p][q][j]\\) 代表当前放到第 \\(i\\) 行，放法为 \\(p\\)，上一行放法为 \\(q\\)，已经放了 \\(j\\) 个马的方案数\n初始状态：\\(dp[1][p][0][popcount(p)] = 1,p \\in [0, 2^n-1]\\) （同一行的马不会互相攻击所以可以随便放）\n转移方程：\\[dp[i][p][q][j] = \\sum_{a} dp[i-1][q][a][j-popcount(p)],j \\in [popcount(p),k],(q,p) \\And (a,p) \\text{不冲突}\\]\n所求结果：\\[\\sum_{p=0}^{2^n-1} \\sum_{q=0}^{2^n-1} dp[m][p][q][k]\\]\n\n注意数据范围 \\(n&lt;=6,~m&lt;=100\\)，即 \\(2^m &gt;&gt; 2^n\\)，故我们把 \\(m\\) 当做行来处理可以极大地缩小空间时间复杂度，最终时间复杂度：\\(O(m \\times 2^n \\times 2^n \\times 2^n \\times k) = O(8^nmk)\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/11.cpp\") \n完美序列\n鸣谢：感谢 @Tifa 大佬提供的主要思路\n读完题目，我们可以轻松获取如下三个结论（以下简称“\\(1\\) 至 \\(n\\) 的所有排列中长度正好为 \\(n\\) 阶最大完美长度的最长完美子序列”为“最长完美子序列”：\n\n\\(n\\) 阶最大完美长度为 \\(\\lfloor \\log_2 n \\rfloor + 1\\)\n每个“最长完美子序列”一定以 \\(1\\) 为结尾\n每个“最长完美子序列”中一定只存在前一个数是后一个数的 \\(2\\) 倍或 \\(3\\) 倍，且 \\(3\\) 倍只出现一次\n\n第一个结论是显然的，因为下降最慢的完美序列为等比数列 \\(2^k,2^{k-1},\\cdots,1\\)，故一个最大值为 \\(n\\) 的完美序列的最大长度为 \\(\\lfloor \\log_2 n \\rfloor + 1\\)\n第二个结论采取反证法：若存在一个“最长完美子序列” \\(P\\) 不以 \\(1\\) 为结尾，那么一定存在一个完美子序列 \\(Q=(P,1)\\) 比 \\(P\\) 长，那么 \\(P\\) 必然不是最长的，矛盾\n第三个结论采取反证法：首先，若出现了 \\(3\\) 倍以上，即以长度 \\(2\\) 出现了 \\(3\\) 倍以上（例：\\(5,1\\)），但我们至少可以用长度 \\(3\\) 来出现 \\(4\\) 倍（\\(4,2,1\\)），也就说说若出现了 \\(3\\) 倍以上，那么此“最长完美子序列”必然不是最长的，矛盾；其次，若出现了两个 \\(3\\) 倍，即以长度 \\(3\\) 出现了 \\(9\\) 倍（例：\\(9,3,1\\)），但我们可以用长度 \\(4\\) 来出现 \\(8\\) 倍（\\(8,4,2,1\\)），也就是说若出现了 \\(9\\) 倍，那么此“最长完美子序列”必然不是最长的，矛盾\n有了如上三个结论，我们就可以开始考虑如何解决这个问题了。设 \\(n\\) 阶最大完美长度为 \\(len=\\lfloor \\log_2 n \\rfloor + 1\\)，我们分情况讨论：\n“最长完美子序列”中不存在 \\(3\\) 倍，即“最长完美子序列”为：\\(2^{len-1} \\rightarrow 1\\)\n此时“最长完美子序列”为等比数列 \\(2^{len-1},2^{len-2},\\cdots,1\\)，由等比数列求和公式 \\(S_n=\\cfrac{a_1-a_{n}q}{1-q}\\)，此情况下“最长完美子序列”的和为：\n\\[\\cfrac{2^{len-1}-1 \\times \\frac{1}{2}}{1-\\frac{1}{2}}=2^{len}-1\\]\n“最长完美子序列”中存在 \\(3\\) 倍，即“最长完美子序列”为：\\(3 \\cdot 2^{len-2} \\rightarrow 1\\)\n注意：只有当 \\(n \\geq 3 \\cdot 2^{len-2}\\) 时才会出现此情况\n设 \\(S_{len}\\) 为存在 \\(3\\) 倍情况下所有长度为 \\(len\\) 的“最长完美子序列”的和，则有：\n\n1\n\n递推预处理即可。以 \\(len=5\\) 为例，上式的各部分如下：\n\n2\n\n当然，也可以使用此递推式的通项公式 \\(S_{len}=2^{len-1}(3len-4) - len + 2\\) 直接算出结果\n于是对于一个给定的 \\(n\\)，我们只需要判断一下是否可能出现第二种情况，根据上文所述即可获取所有“最长完美子序列”的和\n注意“最长完美子序列”是 \\(1\\) 至 \\(n\\) 的所有排列的子序列，也就是说每个“最长完美子序列”会出现多次，其出现次数为 \\(\\cfrac{A_n^n}{A_{len}^{len}}=\\cfrac{n!}{len!}\\)，在计算答案时需要乘进去\n为什么是 \\(\\cfrac{A_n^n}{A_{len}^{len}}\\) 呢？\\(1\\) 至 \\(n\\) 的所有排列共有 \\(A_n^n\\) 个，而其中“最长完美子序列”的相对位置是不变的，所以除掉“最长完美子序列”的排列数 \\(A_{len}^{len}\\)\n注意到出现了有理数取余，需要预处理阶乘及其逆元 \\(\\left[ \\cfrac{n!}{len!} \\equiv n! \\times (len!)^{-1} \\pmod p \\right]\\)。数据规模 \\(n \\leq {10}^6\\) 不是很大，采用 \\(O(n + \\log p)\\) 或者 \\(O(n \\log n)\\) 求逆元都可以。\n若采用 \\(O(n \\log n)\\) 求逆元则总时间复杂度为 \\(O(n \\log n + T)\\)；若采用 \\(O(n + \\log p)\\) 求逆元则总时间复杂度为 \\(O(n + \\log p + T)\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/12/province2/C/12.cpp\") \n","categories":["题解"],"tags":["蓝桥杯"]},{"title":"第十三届蓝桥杯省赛 C/C++ B 组题解","url":"/2022/04/22/LQ13province-CB/","content":" embedpdf(\"题面\", [\"LQ13province_CB\"]) \n九进制转十进制\n送分题，推荐使用 std::stoi 函数，自带进制转换\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/A.cpp\") \n顺子日期\n题面写的很差，对“顺子”没有一个准确的定义（逆序是否算顺子？包括 \\(0\\) 的是否算顺子？）\n若顺子定义为：“从小到大连续三个大于等于 \\(0\\) 的数字”，则本题做法如下：\n首先我们发现年份部分 \\(2022\\) 是无用的，因为其内部不存在顺子，且最后一位也无法作为顺子的一部分（不存在 \\(34\\) 月），故我们只看月日部分即可。\n若顺子位置在前 \\(3\\) 位，则：\n\n月份为 \\(01\\)，那么日期可以为 \\(20 \\sim 29\\)，共 \\(10\\) 个；\n月份为 \\(12\\)，那么日期可以为 \\(30\\) 或 \\(31\\)，共 \\(2\\) 个。\n\n若顺子位置在后 \\(3\\) 位，则：\n\n日期为 \\(12\\)，那么月份可以为 \\(10\\)，共 \\(1\\) 个；\n日期为 \\(23\\)，那么月份可以为 \\(01\\) 或 \\(11\\)，共 \\(2\\) 个。\n\n注意在以上过程中我们计算了 \\(0123\\) 两次，故最终结果为 \\(10+2+1+2-1=14\\)\n刷题统计\n按照题意模拟即可\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/C.cpp\") \n修剪灌木\n当一棵灌木被修剪后其高度会变为 \\(0\\)，而下次再次碰到此灌木时其高度达到最高\n故对于中点左侧的灌木来说，其最大高度为其右侧灌木数量乘 \\(2\\)；对于中点右侧的灌木来说，其最大高度为其左侧灌木数量乘 \\(2\\)。\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/D.cpp\") \nX 进制减法\n题面解释\n首先我们解释一下题面里的 \\(321\\) 转换后为什么是 \\(65\\)\n设一个 \\(X\\) 进制数字 \\(P\\) 每位的数字为 \\(p_1,p_2,\\cdots,p_n\\)，即 \\(P = \\overline{p_{1}p_{2} \\cdots p_{n}}\\)，每位的进制为 \\(x_1,x_2,\\cdots,x_n\\)\n则其十进制值为 \\(p_1(x_{2}x_{3} \\cdots x_{n}) + p_2(x_{3}x_{4} \\cdots x_{n}) + \\cdots + p_n\\)\n即：\n\\[P = \\sum_{i=1}^{n} \\left( p_i \\prod_{j=i+1}^{n}x_j \\right)\\]\n故 \\((321)_X = 3 \\times (10 \\times 2) + 2 \\times 2 + 1 = 65\\)\n解题\n设 \\(A\\) 每位的数字为 \\(a_1,a_2,\\cdots,a_n\\)，\\(B\\) 每位的数字为 \\(b_1,b_2,\\cdots,b_m~(m \\leq n)\\)。\n若 \\(m&lt;n\\)，为了方便，我们在 \\(B\\) 数字前面补前导 \\(0\\)，使得其长度与 \\(A\\) 一样。则 \\(B\\) 每位的数字为 \\(b_1,b_2,\\cdots,b_n\\)。\n设每位的进制为 \\(x_1,x_2,\\cdots,x_n\\)，则：\n\\[\n\\begin{aligned}\n    A-B &amp;= \\sum_{i=1}^{n} \\left( a_i \\prod_{j=i+1}^{n}x_j \\right) - \\sum_{i=1}^{n} \\left( b_i \\prod_{j=i+1}^{n}x_j \\right) \\\\\n        &amp;= \\sum_{i=1}^{n} \\left( (a_i-b_i) \\prod_{j=i+1}^{n}x_j \\right)\n\\end{aligned}\n\\]\n在 \\(a_i\\) 与 \\(b_i\\) 都给定的情况下，可以发现当 \\(\\prod_{j=i+1}^{n}x_j\\) 越小时，\\(A-B\\) 越小，也就是每位的进制都取到最小值时，\\(A-B\\) 最小\n注意题面的规定“最低为二进制”与“每一数位上的数字要小于其进制”，故每位的进制最小只能取到 \\(\\max(2, a_i+1, b_i+1)\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/E.cpp\") \n统计子矩阵\n首先有一个很显然的二维前缀和暴力，但时间复杂度为 \\(O(n^4)\\)，对于 \\(500\\) 的数据范围显然无法接受\n我们发现，子矩阵是连续的，故本题其实即双指针算法维护区间信息的模板题的二维版本\n\n双指针算法维护区间信息的模板题：LeetCode 713 给定一个正整数数组 \\(nums\\) 和整数 \\(k\\) 。 请找出该数组内乘积小于 \\(k\\) 的连续的子数组的个数。\n\n在一维数组中使用双指针时，两个指针指向的是零维的点，那么在二维数组中使用双指针时，双指针自然指向的就是一维的线\n于是我们只需要遍历这两根一维的线，扫双指针即可。而两线之间元素的和的维护可以使用前缀和轻松解决\n一个循环遍历两线的左边界，一个循环遍历两线的右边界，一个循环在限定的左右边界范围内在纵方向扫双指针，时间复杂度 \\(O(n^3)\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/F.cpp\") \n积木画\n洛谷原题：覆盖墙壁\n发现问题要求方案数，而求方案数的题目一般就是两种做法：组合数学或者动态规划。本题显然不像是可以用组合数学解决的，考虑动态规划\n以下提供两种动态规划的方法\n线性 DP\n朴素递推\n\n状态设计：\\(dp[i]\\) 代表前 \\(i\\) 列都被填满时的方案数\n初始状态：\\(dp[0] = 1\\)\n转移方程：\n\n若最后一个放的是竖条\n\n\\(dp[i-1]+\\) 第 \\(i\\) 列放一个竖条 \\(=dp[i]\\)\n\n\\(dp[i-2]+\\) 第 \\(i-1\\) 与 第 \\(i\\) 列放两个横条 \\(=dp[i]\\)\n\n\n若最后一个放的是 L 条，最后一个放的 L 条有两种放法，故答案乘 \\(2\\)\n\n\\(dp[i-3]+\\) 放两个 L 条 \\(=dp[i]\\)\n\n\\(dp[i-4]+\\) 两个 L 条一个横条 \\(=dp[i]\\)\n\n\\(dp[i-5]+\\) 两个 L 条两个横条 \\(=dp[i]\\)\n\n\\(\\vdots\\)\n\n\n即：\n\\[\n    \\begin{aligned}\n        dp[i] &amp;= dp[i-1]+dp[i-2]+2\\sum_{j=0}^{i-3}dp[j] \\\\\n              &amp;= dp[i-1]+\\left( dp[i-2]+dp[i-3]+2\\sum_{j=0}^{i-4}dp[j] \\right)+dp[i-3] \\\\\n              &amp;= 2dp[i-1] + dp[i-3]\n    \\end{aligned}\n\\]\n所求结果：\\(dp[n]\\)\n\n可以滚动数组优化\n矩阵加速\n显然以上转移方程可以矩阵加速：\n\\[\n    \\begin{cases}\n        2 \\times dp[i-1] + 0 \\times dp[i-2] + 1 \\times dp[i-3] = dp[i] \\\\\n        1 \\times dp[i-1] + 0 \\times dp[i-2] + 0 \\times dp[i-3] = dp[i-1] \\\\\n        0 \\times dp[i-1] + 1 \\times dp[i-2] + 0 \\times dp[i-3] = dp[i-2]\n    \\end{cases}\n    \\Rightarrow\n    \\begin{bmatrix}\n        2 &amp; 0 &amp; 1 \\\\\n        1 &amp; 0 &amp; 0 \\\\\n        0 &amp; 1 &amp; 0\n    \\end{bmatrix}\n    \\begin{bmatrix}\n        dp[i-1] \\\\\n        dp[i-2] \\\\\n        dp[i-3]\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n        dp[i] \\\\\n        dp[i-1] \\\\\n        dp[i-2]\n    \\end{bmatrix}\n\\]\n当 \\(n&gt;3\\) 时：\n\\[\n    \\begin{bmatrix}\n        dp[i] \\\\\n        dp[i-1] \\\\\n        dp[i-2]\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n        2 &amp; 0 &amp; 1 \\\\\n        1 &amp; 0 &amp; 0 \\\\\n        0 &amp; 1 &amp; 0\n    \\end{bmatrix}^{n-3}\n    \\begin{bmatrix}\n        dp[3] \\\\\n        dp[2] \\\\\n        dp[1]\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n        2 &amp; 0 &amp; 1 \\\\\n        1 &amp; 0 &amp; 0 \\\\\n        0 &amp; 1 &amp; 0\n    \\end{bmatrix}^{n-3}\n    \\begin{bmatrix}\n        5 \\\\\n        2 \\\\\n        1\n    \\end{bmatrix}\n\\]\n状压 DP\n\\(j=(0,1)\\) 代表第一行是否被填充，\\(k=(0,1)\\) 代表第二行是否被填充\n\n状态设计：\\(dp[i][j][k]\\) 代表前 \\(i-1\\) 列已经填满，第 \\(i\\) 列的填法为 \\((j,k)\\) 时的方案数\n初始状态：\\(dp[1][0][0] = 1\\)\n转移方程： 若第 \\(i\\) 列没被填满，我们向第 \\(i\\) 列上放置积木将其填满，而在这个填充的过程中可能会影响到第 \\(i+1\\) 列：\n\n\\(dp[i][0][0] \\rightarrow dp[i+1][0][0]\\)\n\n\\(dp[i][0][0] \\rightarrow dp[i+1][1][1]\\)\n\n\\(dp[i][0][0] \\rightarrow dp[i+1][0][1]\\)\n\n\\(dp[i][0][0] \\rightarrow dp[i+1][1][0]\\)\n\n\\(dp[i][0][1] \\rightarrow dp[i+1][1][0]\\)\n\n\\(dp[i][0][1] \\rightarrow dp[i+1][1][1]\\)\n\n\\(dp[i][1][0] \\rightarrow dp[i+1][0][1]\\)\n\n\\(dp[i][1][0] \\rightarrow dp[i+1][1][1]\\)\n\n\\(dp[i][1][1] \\rightarrow dp[i+1][0][0]\\)\n\n\n所求结果：\\(dp[n+1][0][0]\\)\n\n每列状态只与上一列有关，故可以滚动数组优化\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/G.cpp\") \n扫雷\n乍一看很像 [NOIP2017 提高组] 奶酪，但一看数据范围发现 \\(O(n^2)\\) 的时间复杂度过 \\(5 \\times {10}^4\\) 有点悬\n但是注意到 \\(r\\) 最大只有 \\(10\\)，故对于一个结点我们可以枚举 \\(r\\) 来获取其能炸到的位置，所以直接搜索就是了。需要注意的是 \\(x,y \\leq {10}^9\\)，我们不能用二维数组存地图，需要使用哈希表 std::unordered_map。另外，std::pair 没有哈希，需要我们自己写一个哈希函数，方法是特化仿函数 std::hash\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/H.cpp\") \n李白打酒加强版\n又是求方案数，一看又不太可能是组合数学，于是 DP。总共就三个变量：店、花、酒的数量，状态设计很简单：\n\n状态设计：\\(dp[i][j][k]\\) 代表李白遇到了 \\(i\\) 个店，\\(j\\) 个花，手上还剩 \\(k\\) 壶酒的方案数\n初始状态：\\(dp[0][0][2] = 1\\)\n转移方程：\\(dp[i][j][k] = dp[i-1][j][\\frac{k}{2}]+dp[i][j-1][k+1]\\)\n注意：\n\n只有 \\(i \\neq 0\\) 且 \\(2|k\\) 时才计算 \\(dp[i-1][j][\\frac{k}{2}]\\) 这个状态\n只有 \\(j \\neq 0\\) 时才计算 \\(dp[i][j-1][k+1]\\) 这个状态\n\\(k\\) 这一维度只需要遍历到 \\(m-j\\) 就足够了，因为每遇到一个花只会喝掉一壶酒，若当前酒的数量大于剩余花的数量则即使之后遇到的都是花酒都喝不完，对最后的答案没有贡献\n\n所求结果：\\(dp[n][m-1][1]\\)\n注意不是 \\(dp[n][m][0]\\)，因为这样就包含了最后一个单位是店的状态，与题目要求矛盾\n\n embedcode(\"递推\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/I1.cpp\") \n embedcode(\"记忆化搜索\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/I2.cpp\") \n砍竹子\n其实就是 [NOIP2018 提高组] 铺设道路 的加强版而已\n回想一下铺设道路的做法：对于除了第一个坑的每一个坑来说，若坑深度大于前一个坑的深度，那么其对答案的贡献就是两坑高度之差，最终答案就是第一个坑的深度加上每个坑对于答案的贡献\n为什么这样做是对的呢？因为在填一下小坑的时候势必会连带着填一下大坑，而小坑填满后大坑剩余的高度就是两坑高度之差了\n我们把这个想法反过来想，也就是：先把大坑填到与小坑一样的高度，然后大小坑一起填\n注意，为什么两个一样深的坑可以一起填？因为每次填土后两坑的高度还是一样的，也就是两坑填充过程中有一个公共的后缀\n回到本题，对于某根竹子来说，若其与前一根竹子在砍的过程中的高度有一个公共的后缀的话，那么不就跟填坑是一样的道理嘛\n注意此时并没有类似“若坑深度大于前一个坑的深度”的限制，因为对于填坑来说，不满足这个条件的坑一定会被填前一个坑的过程中顺带填掉。但是砍竹子不是这样，高的竹子并不一定会有矮的竹子被砍的过程中的高度的后缀，也就是不满足前述条件的竹子不一定会被顺带砍掉\n故某根竹子对于答案的贡献即为其被砍过程中与前一根竹子的公共后缀之外的部分的高度的数量\n故 \\(O(kn)\\) 扫一遍即可，\\(k\\) 为砍竹子的复杂度，高度最大为 \\({10}^{18}\\)，最多砍 \\(6\\) 刀就砍到 \\(1\\) 了，故 \\(k\\) 最大为 \\(6\\)\n embedcode(\"Code\", \"https://github.com/StableAgOH/solved-problems/blob/main/lq/13/province/CB/J.cpp\") \n","categories":["题解"],"tags":["蓝桥杯"]}]